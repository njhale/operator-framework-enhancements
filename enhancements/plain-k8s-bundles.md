---
title: plain-k8s-bundles
authors:
  - "@exdx"
  - "@njhale"
reviewers:
  - TBD
approvers:
  - TBD
creation-date: 2020-03-09
last-updated: 2020-03-09
status: implementable
---

# plain-k8s-bundles

## Release Signoff Checklist

- [x] Enhancement is `implementable`
- [ ] Design details are appropriately documented from clear requirements
- [ ] Test plan is defined
- [ ] Graduation criteria for dev preview, tech preview, GA
- [ ] User-facing documentation is created in [openshift/docs]

## Summary

Add support for a new mediatype, `k8s+v1`, to the [Operator Bundle spec](https://github.com/openshift/enhancements/blob/master/enhancements/olm/operator-bundle.md), [operator-registry](https://github.com/operator-framework/operator-lifecycle-manager/blob/master/pkg/api/apis/operators/v1alpha1/clusterserviceversion_types.go), and [OLM](https://github.com/operator-framework/operator-lifecycle-manager) that enables packaging an operator without defining a [ClusterServiceVersion](https://github.com/operator-framework/olm-book).

## Motivation

Operator authors find CSVs difficult to write and maintain. Expressing an OLM-managed operator as a set of related kubernetes objects is more intuitive to users. Supporting plain kubernetes manifests makes OLM more approachable to the wider community, which is relevant in light of the Operator Framework attempting to become a CNCF project. This feature is part of the overall goal of making OLM simpler to use.

Furthermore, this feature is part of the overall goal of making OLM more flexible by supporting more media types. The more media types OLM supports the more popular and accesible OLM becomes.

### Goals

- Support, install, build, and lifecycle `k8s+v1` bundles  
- Support adding `k8s+v1` bundles to an [Operator Index](https://github.com/openshift/enhancements/blob/master/enhancements/olm/operator-registry.md#summary)
- Support packageserver surfacing data on plain manifest bundles

### Non-Goals

- Supporting helm bundles
- Building a bundle without providing any additional metadata in some way
- Implement operatorhub.io usage of this new mediatype

## Proposal

### New Mediatype

The `k8s+v1` mediatype will be used to represent a bundle composed of plain Kubernetes manifests. This will let OLM and other tooling differentiate this type of bundle from other types.

### Inferring CSV Content

CSVs are generally ⅔s standard k8s manifests and ⅓ operator runtime information. They provide a description that can be used to gather dependencies for, install, and display an operator. When attempting to denormalize this description, it's critical that there is no loss of information capacity. To this end, it helps to split it into two categories: inferrable and non-inferrable.

#### Inferrable

To support a wider range of inferred CSV fields, manifests for resources usually generated by a CSV will need to be provided as input to `k8s+v1` bundle creation:

- Deployments for InstallStrategy
- RBAC w/ subjects matching Deployment ServiceAccounts for Permissions and Owned, Required, and NativeAPIs
- APIServices and Services for APIServiceDefinitions

Required, provided, optional, and native APIs in a `k8s+v1` bundle will inferred by inspecting the RBAC, CRDs, Deployments, and APIServices it contains using the following rules:

- the GVK of any CRD in the bundle will be considered a **provided API**
- a GVK referenced in RBAC with a subject shared by the Deployment will be considered:
  - **optional** if the referencing `(Cluster)RoleBinding` has the `operators.operatorframework.io.bundle.dependency="optional"` annotation set
    - i.e. the GVK is neither provided or required
  - **provided** if it belongs to the group version of an APIService in the bundle
  - **required** if it DOES NOT belong to:
    - any group version defined by an APIService or CRD in the bundle
    - a `*.k8s.io` group
- `nonResourceURLs` referenced in RBAC with a subject shared by the Deployment will be considered **native APIs**

The dependence on explicit kinds in RBAC rules means that rules with wildcard types (i.e. `*`) are disallowed in `k8s+v1` bundles. This may seem like a burdensome restriction, but a nice corollary is that all `k8s+v1` bundles follow [the principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege). The exception to the restriction is RBAC w/ subjects that do not match a ServiceAccount in the bundle's Deployments.

#### Non-Inferrable

The following are parts of a CSV that are NOT directly inferrable from plain kubernetes resources:

- Name
- Descriptors
- Description
- Display Name
- Keywords
- Labels
- Links
- Maintainers
- Maturity
- Provider
- Selector
- Icon
- Runtime Metadata
- MinKubeVersion
- (Future) Optional APIs
- Replaces
- Version
- InstallModes

This non-inferrable data will be gathered through a mixture of resource annotations and an `olm.yaml` file in the `metadata` directory of the bundle.

Ex. _olm.yaml_

```yaml
name: packageserver-v1.14.1
maturity: alpha
version: 0.14.1
displayName: Package Server
description: Represents an Operator package that is available from a given CatalogSource which will resolve to a ClusterServiceVersion.
minKubeVersion: 1.11.0
keywords: ['packagemanifests', 'olm', 'packages']
maintainers:
- name: Red Hat
email: openshift-operators@redhat.com
provider:
name: Red Hat
links:
- name: Package Server
url: https://github.com/operator-framework/operator-lifecycle-manager/tree/master/pkg/package-server
installModes:
- type: OwnNamespace
  supported: true
- type: SingleNamespace
  supported: true
- type: MultiNamespace
  supported: true
- type: AllNamespaces
  supported: true
icon: my-icon-png-base64-encoded
labels:
  operated-by: packageserver
```

### User Stories

#### Story 1

As an operator author, Alice wants to package her operator for use with OLM. She doesn't have prior knowledge of OLM and wants to do the minimum to package her operator up.

Alice has a set of kubernetes manifests describing her operator already: a single CRD, a Service, a Deployment, and some RBAC rules (a fairly straightforward operator deployment). As a user she is able to take these manifests and run an opm command to build a valid bundle. The bundle will include all the necessary metadata for OLM to manage the operator and surface it in a catalog.

OLM is then able to take this bundle and install it in the cluster from a subscription to a catalog source containing the bundle. OLM installs the operator by constructing a CSV representation of the kubernetes objects and then generating an InstallPlan.

The end result is a valid OLM-managed operator deployment running in the cluster, and Alice having a good user experience packaging her existing operator.

#### Story 2

As a pipeline maintainer, Bob wants to package an operator, described as a set of kubernetes manifests, and add it to an index image. The existing index image he is using contains a variety of bundles, both of the `registry+v1` and `k8s+v1` type. Bob expects that by running opm commands he will be able to produce a new index image containing his operator. The catalog source running this image can successfully serve the operator, and the packageserver can surface information on this operator both in-cluster and via the console.

The end result is Bob is able to more easily update and incorporate OLM into his existing pipeline.  

### Risks and Mitigations

One risk is around backporting indexes with mixed mediatypes to older clusters. This needs to be supported to ensure upgrades and downgrades of OpenShift behave as intended. This is outlined further in the Upgrade/Downgrade section below.

Another risk is around operatorhub.io - it will need to be adjusted to support the `k8s+v1` bundles. This work is not scoped as part of this enhancement and is done by a seperate team - how much effort is involved there is unclear.

Security impacts are minimal because the number of kubernetes objects that OLM supports is still the same - just the delivery mechanism (the bundle format) is changing.

## Design Details

### Implementation Details

#### Required Manifests

The absence of a CSV means that there is a set of manifests that must ALWAYS be present to build `k8s+v1` bundles. These manifests are ALWAYS __required__:

- a `Deployment` for the operator
- a `metadata/olm.yaml` file with the following fields
  - name
  - version
  - minKubeVersion
  - installModes

In certain situations, more manifests are required:

- providing an API from an APIService requires
  - an `APIService`
  - the `Service` it references
- providing an admission webhook
  - a `MutatingWebhookConfiguration` or a `ValidatingAdmissionWebhook`
  - the `Service` it references

Other manifests are `optional`:

- `Roles`, `RoleBindings`, `ClusterRoles`, and `ClusterRolesBindings`
- `CustomResourceDefinitions`

#### `opm` Support

[`opm`](https://github.com/operator-framework/operator-registry#overview) must be updated to provide support for building `k8s+v1` bundles. This can be acheived with explicit flags or through CSV/olm.yaml file presence.

#### CSV Synthesis

OLM will support `k8s+v1` bundles by synthesizing a CSV from its content. Resources usually generated by a CSV (e.g. APIService and Service) will not be directly applied, but instead be projected onto a synthesized CSV.

This intermediary step (creating a CSV internally to represent the kubernetes objects) is a delibrate decision in 4.5 to help focus and deliver the feature. This may be relaxed in future release versions.

#### Validation

The [operator-framework static validation package](https://github.com/operator-framework/api/tree/master/pkg/validation) can be extended and used to validate the content being fed into a `k8s+v1` bundle build. New validators will be added to `opm` which ensure all required manifests and metadata are present and valid.

#### Indexes

When a `k8s+v1` bundle is added to an index, `opm` will also synthesize and add a CSV. A lot of the existing `opm` and `operator-registry` code assumes bundles always contain CSVs, which make synthesis the simplest path to supporting `k8s+v1` bundles -- in the future, we may want to revisit this decision, especially when the [`Operator` API](https://github.com/openshift/enhancements/blob/master/enhancements/olm/simplify-apis.md#proposal) is released.

To fill out the dependency graph between versions of bundles, OLM considers the "replaces" field on the CSV which points to the previous version of the operator. This field will need to be supplied in the additional metadata the operator author provides in the bundle so that OLM can build dependency graphs. There is another enhancement around semantic versioning that would remove this requirement altogether, but it is independent of this enhancement.

Supporting indexes with different mediatypes is a key requirement. Both `k8s+v1`  and `registry+v1` type bundles should be able to be added to an existing index. There is the potential of versioning the index itself to help differentiate between newer index images, that include the `k8s+v1` mediatype, and older versions.

#### Resolving, Unpacking, and Applying

At install, a CSV must be generated for a `k8s+v1` bundle so that OLM can manage the operator it represents on the cluster. It must also take care not to apply any bundle resources that are usually generated by a CSV (e.g. APIService and Service). This means that when OLM resolves and unpacks a bundle, it needs to recognize its mediatype and take appropriate action.

#### Legacy Support for AppRegistry

A bundle of type `k8s+v1` can be stored in an AppRegistry type catalog after synthesizing a CSV and removing resources that are usually generated by CSVs. This allows clusters with AppRegistry type catalogs to receive updates to operators whose authors have switched to publishing `k8s+v1` bundles.

### Test Plan

There will be e2e tests alongside unit tests. The e2e test will verify that the functionality is delivered as expected - bundles consisting just of kubernetes manifests are installed and managed on cluster by OLM. Potentially existing tests can be reused but with the newer bundle format.

Outside of core OLM there will also be tests in operator-registry to ensure the new bundle format is consistently generated as we expect. Its also critical to test how indexes composed of k8s+v1 bundles will behave.

### Upgrade / Downgrade Strategy
  
Upgrade (not supporting `k8s+v1` mediatype -> supporting `k8s+v1` mediatype)

- Older versions of OpenShift may install newer catalog source images that contain both the new `k8s+v1` format and the legacy `registry+v1` format. Its important that OLM continues to behave as expected in these cases, even if it cannot install the `k8s+v1` bundles explicitly. This may require a small patch to be backported to 4.x versions of OpenShift. This would not necessarily affect upstream OLM users as they can simply update OLM to use the new feature.
- An updated version of OLM that supports the `k8s+v1` mediatype should be a safe upgrade - if the catalogsources do not have any bundles using the new format, there should be no change. Bundles in the `k8s+v1` mediatype format available in the updated cluster should be available to list via the packageserver and install.

Downgrade (supporting `k8s+v1` mediatype -> not supporting `k8s+v1` mediatype)

- OpenShift supports a downgrade path and so OLM must ensure that it can continue working even if the ability to install `k8s+v1` format is removed as OLM is downgraded to an older version. OLM should be able to reject bundle formats that it cannot successfully reconcile and emit a helpful error message in that case.
